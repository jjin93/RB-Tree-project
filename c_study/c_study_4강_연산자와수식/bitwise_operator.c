/* 비트 연산자 : 비트를 연산할 때 쓰이는 비트 연산자를 배우자. 비트 연산은 정수나 정수로 변환 가능한 타입만 가능하며,
                실수 나 포인터 등은 비트 연산을 할 수 없다.
                비트는 바이트 단위보다 더 작은 단위이며, 2진수를 저장한다. 즉 컴퓨터에서 사용할 수 있는 최소 단위이며,
                0과 1을 나타낸다. 비트 연산자는 흔하게 사용되지는 않지만 적절한 때에 사용하면 메모리 공간의 효율성을 높이고
                연산의 수를 줄일 수 있다. 또한 비트 단위로 계산하기 때문에 일반적인 사칙연산 보다 훨씬 속도가 빠르다.
                연산자의 종류 :
                연산자         기능
                  &           AND 연산
                  |           OR 연산
                  ^           XOR 연산
                  ~           모든 비트 반전, NOT 연산
                  <<          지정한 수만큼 비트 열을 왼쪽으로 이동
                  >>          지정한 수만큼 비트 열을 오른쪽으로 이동
*/

/* 연산자(AND)
&연산자는 논리연산자의 &&연산자와 헷갈릴 수 있는데, 논리 연산은 true,false를 반환하고 비트 연산은 값을 반환한다는 것을 기억할것.
또한 이 "&연산자는 주소값을 가리키는 거 아니었나?" 하지만 그것도 맞다. 주소값을 가리키는 &연산자는
단항 연산자 로서, 피연산자가 1개만 필요하다. 즉 &b 와 같은 한개의 변수만 필요로 한다. 하나의 변수 앞에 쓰여 질때에는 주소값을
나타내지만, a & b 와 같이 쓰여질때는 비트연산의 AND를 나타낸다.
    A       B       결과값
    0       0       0
    0       1       0
    1       0       0
    1       1       1

    논리곱 연산과 같아보이지만 이 연산을 비트에 사용한다는 것이 포인트. 이때 비교하는 비트는 각 수를 2진수로 변환한 후 각 자리를
    &연산자로 비교해서 값이나온다. */

#include <stdio.h>

int main()
{
      /* 굳이 unsigned char을 쓰는 이유는? char는 8비트 변수로써 signed의 경우 -128~127까지, unsigned의 경우 0~255까지 사용가능하다
    int의 경우는 32비트 변수로 -2147483648 ~ 2147483647까지 사용가능하다. 비트연산을 쉽게 이해하기 위해 작은 숫자를
    이용할 것이므로 메모리 효율 측면에서 봤을 때 굳이 32비트까지 쓸 필요가 없다, 따라서 char을 쓴다.
    거기에 추가로 signed의 경우 "부호 있는 정수"라 하여 맨 왼쪽 비트는 부호비트이다. 이 부호비트를 MSB 라 부르며 0이면양수,
    1이면 음수를 나타낸다. 따라서 MSB가 1이 되면 음수로 계산 되어 보수연산을 하게되는데, 이 보수연산이 조금 까다로우므로 부호 비트
    에 영향을 주지 않도록 unsigned를 이용했다. */
  
	unsigned char a = 4;  // 0000 0100
	unsigned char b = 8;  // 0000 1000
	unsigned char c = a & b;
    unsigned char d = a | b;
	unsigned char e = a ^ b;
    
	printf("4와 8의 AND 연산 값 : %d\n", c);
	printf("4와 8의 OR 연산 값 : %d\n", d);
	a = 6;  // 0000 0110
	b = 13; // 0000 1101
	c = a & b;
    d = a | b;
	
	printf("6과 13의 AND 연산 값 : %d\n", c);
	printf("6과 13의 OR 연산 값 : %d\n", d);
	return 0;

}    


